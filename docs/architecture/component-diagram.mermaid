classDiagram
    direction LR

    class Calculator {
        <<interface>>
        +Calculate(ctx, progressChan, calcIndex, n, opts) *big.Int, error
        +Name() string
    }

    class coreCalculator {
        <<interface>>
        +CalculateCore(ctx, reporter, n, opts) *big.Int, error
        +Name() string
    }

    class FibCalculator {
        -core coreCalculator
        +Calculate(ctx, progressChan, calcIndex, n, opts) *big.Int, error
        +CalculateWithObservers(ctx, subject, calcIndex, n, opts) *big.Int, error
        +Name() string
    }

    class CalculatorFactory {
        <<interface>>
        +Create(name) Calculator, error
        +Get(name) Calculator, error
        +List() []string
        +Register(name, creator) error
        +GetAll() map
    }

    class DefaultFactory {
        -creators map
        -calculators map
        -mu sync.RWMutex
        +Register(name, creator) error
        +Create(name) Calculator, error
        +Get(name) Calculator, error
        +List() []string
        +GetAll() map
    }

    class Multiplier {
        <<interface>>
        +Multiply(z, x, y, opts) *big.Int, error
        +Square(z, x, opts) *big.Int, error
        +Name() string
    }

    class DoublingStepExecutor {
        <<interface>>
        +Multiply(z, x, y, opts) *big.Int, error
        +Square(z, x, opts) *big.Int, error
        +ExecuteStep(ctx, state, opts, inParallel) error
        +Name() string
    }

    class AdaptiveStrategy {
        -fftThreshold int
        +Multiply(z, x, y, opts) *big.Int, error
        +Square(z, x, opts) *big.Int, error
        +ExecuteStep(ctx, state, opts, inParallel) error
    }

    class FFTOnlyStrategy {
        +Multiply(z, x, y, opts) *big.Int, error
        +Square(z, x, opts) *big.Int, error
        +ExecuteStep(ctx, state, opts, inParallel) error
    }

    class KaratsubaStrategy {
        +Multiply(z, x, y, opts) *big.Int, error
        +Square(z, x, opts) *big.Int, error
        +ExecuteStep(ctx, state, opts, inParallel) error
    }

    class DoublingFramework {
        -strategy DoublingStepExecutor
        +ExecuteDoublingLoop(ctx, reporter, n, opts, state, useParallel) *big.Int, error
    }

    class MatrixFramework {
        -multiplier Multiplier
        +ExecuteMatrixLoop(ctx, reporter, n, opts, state) *big.Int, error
    }

    class ProgressObserver {
        <<interface>>
        +Update(calcIndex, progress)
    }

    class ProgressSubject {
        -observers []ProgressObserver
        -mu sync.RWMutex
        +Register(observer)
        +Notify(calcIndex, progress)
        +Freeze(calcIndex) ProgressCallback
    }

    class ChannelObserver {
        -channel chan ProgressUpdate
    }

    class LoggingObserver {
        -logger zerolog.Logger
        -threshold float64
        -lastLog map
    }

    class NoOpObserver {
    }

    class ProgressReporter {
        <<interface>>
        +DisplayProgress(wg, progressChan, numCalculators, out)
    }

    class ResultPresenter {
        <<interface>>
        +PresentComparisonTable(results, out)
        +PresentResult(result, n, verbose, details, showValue, out)
        +FormatDuration(d) string
        +HandleError(err, duration, out) int
    }

    class TempAllocator {
        <<interface>>
        +AllocFermatTemp(n) fermat, func()
        +AllocFermatSlice(K, n) []fermat, []big.Word, func()
    }

    class BumpAllocator {
        -buffer []big.Word
        -offset int
        +Alloc(n) []big.Word
        +AllocFermat(n) fermat
        +AllocFermatSlice(K, n) []fermat, []big.Word
    }

    class BumpAllocatorAdapter {
        -ba *BumpAllocator
        +AllocFermatTemp(n) fermat, func()
        +AllocFermatSlice(K, n) []fermat, []big.Word, func()
    }

    class PoolAllocator {
        +AllocFermatTemp(n) fermat, func()
        +AllocFermatSlice(K, n) []fermat, []big.Word, func()
    }

    class TransformCache {
        -entries map
        -config TransformCacheConfig
        +Get(data, k, n) PolValues, bool
        +Put(data, pv)
        +Stats() CacheStats
        +Clear()
    }

    class DynamicThresholdManager {
        -metrics []IterationMetric
        -ringPos int
        +RecordIteration(bitLen, duration, usedFFT, usedParallel)
        +ShouldAdjust() newFFT, newParallel, adjusted
        +GetThresholds() fft, parallel
        +GetFFTThreshold() int
        +GetParallelThreshold() int
    }

    class Options {
        +ParallelThreshold int
        +FFTThreshold int
        +StrassenThreshold int
        +FFTCacheMinBitLen int
        +FFTCacheMaxEntries int
        +FFTCacheEnabled *bool
        +EnableDynamicThresholds bool
        +DynamicAdjustmentInterval int
    }

    Calculator <|.. FibCalculator
    coreCalculator <|.. FibCalculator : wraps
    CalculatorFactory <|.. DefaultFactory
    Multiplier <|.. AdaptiveStrategy
    Multiplier <|.. FFTOnlyStrategy
    Multiplier <|.. KaratsubaStrategy
    DoublingStepExecutor <|.. AdaptiveStrategy
    DoublingStepExecutor <|.. FFTOnlyStrategy
    DoublingStepExecutor <|.. KaratsubaStrategy
    DoublingStepExecutor --|> Multiplier : extends
    ProgressObserver <|.. ChannelObserver
    ProgressObserver <|.. LoggingObserver
    ProgressObserver <|.. NoOpObserver
    TempAllocator <|.. BumpAllocatorAdapter
    TempAllocator <|.. PoolAllocator
    BumpAllocatorAdapter --> BumpAllocator : wraps

    DoublingFramework --> DoublingStepExecutor : uses
    DoublingFramework --> Options : configured by
    DoublingFramework --> ProgressSubject : reports to
    MatrixFramework --> Multiplier : uses
    MatrixFramework --> Options : configured by
    FibCalculator --> ProgressSubject : creates
    ProgressSubject --> ProgressObserver : notifies
    DefaultFactory --> FibCalculator : creates
    DoublingFramework --> DynamicThresholdManager : optional
    AdaptiveStrategy --> TransformCache : optional
